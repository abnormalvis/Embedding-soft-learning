# 操作运算符

## 分类一览
- **算术**：`+ - * / % ++ --`
- **关系**：`< <= > >= == !=`
- **逻辑**：`&& || !`
- **位运算**：`& | ^ ~ << >>`
- **赋值**：`=` 以及复合赋值 `+= -= &=` 等
- **其他**：`?:` 条件运算符、`,` 逗号运算符、`sizeof`、`&` 取地址、`*` 解引用、`->` 结构体指针成员访问、`[]` 下标、函数调用 `()`

## 优先级与结合性
- `()`、`[]`、`.`、`->` 优先级最高，自左向右结合。
- 单目运算符如 `! ~ ++ -- (type)` 自右向左结合。
- 乘除模高于加减；位移位于关系运算之前；逻辑运算符 `&&` 优先于 `||`。
- 赋值运算符自右向左结合，表达式 `a = b = 1;` 会先计算右侧。
- 为避免歧义，适当添加括号；在代码审查中关注潜在的优先级误判。

## 类型转换
- 算术运算存在“整型提升”和“常规算术转换”，短整数(`char`/`short`)通常会提升为 `int`。
- 混合运算中若存在 `double`，会将其它操作数转换为 `double`。
- 使用强制类型转换时应明确目的，避免截断或精度损失。

## 评估顺序
- C17 之前，多数运算符的求值顺序未定义，不能依赖副作用执行的顺序。
- 例如 `f(i++, i++)` 未定义行为；`x = i++ + ++i;` 同样不可预测。
- `&&`、`||`、`?:`、`,` 和赋值运算符在 C17 中定义了从左到右的求值顺序，但其内部副作用仍应谨慎使用。

## 位运算技巧
- 置位：`flags |= MASK;`
- 清零：`flags &= ~MASK;`
- 切换：`flags ^= MASK;`
- 检查：`if ((flags & MASK) != 0)`
- 利用移位构建掩码，如 `1u << bit`。

```c
unsigned pack_rgb(unsigned r, unsigned g, unsigned b) {
    return ((r & 0xFFu) << 16) | ((g & 0xFFu) << 8) | (b & 0xFFu);
}
```

## 条件运算符
- `cond ? expr1 : expr2` 根据条件选择表达式结果，可用于内联简洁逻辑。
- 两个分支的类型会根据常规算术转换推导；若无法兼容，则需要显式转换。

## 常见陷阱
- 使用 `=` 代替 `==` 导致意外赋值，可以开启编译器警告。
- 模运算 `%` 在负数场景返回同号余数，跨平台时应确认行为符合预期。
- 左移超过位数或对负数右移属于未定义行为，编写移位代码时需做好边界检查。
