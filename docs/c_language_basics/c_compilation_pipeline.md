# C语言编译原理

## 总览
```
源文件(.c/.h)
   │
   ├─(预处理)─▶ .i    // 宏展开、条件编译、头文件插入
   ├─(编译)───▶ .s    // 语法分析、优化、生成汇编
   ├─(汇编)───▶ .o    // 汇编器将指令翻译成机器码
   └─(链接)───▶ 可执行文件/库
```
- 预处理负责处理 `#include`、`#define`、`#if` 等指令。
- 编译阶段将 C 源码转为目标指令，执行语义检查和大部分优化。
- 汇编阶段把汇编指令转换为当前平台的机器码并写入目标文件。
- 链接阶段解析外部符号，合并多个目标文件，最终生成可执行文件或库。

## 常用命令
| 阶段 | 命令示例 | 说明 |
| ---- | -------- | ---- |
| 预处理 | `gcc -E main.c -o main.i` | 查看宏展开后的文本，便于定位条件编译问题 |
| 编译 | `gcc -S main.c -o main.s` | 输出汇编文件，观察编译器生成的指令 |
| 仅编译不链接 | `gcc -c main.c -o main.o` | 生成目标文件，适合多文件项目的增量构建 |
| 链接 | `gcc main.o util.o -o app` | 把多个目标文件链接为可执行文件 |
| 静态库 | `ar rcs libmath.a math.o` | 打包目标文件供静态链接使用 |
| 动态库 | `gcc -shared -fPIC math.c -o libmath.so` | 构建可被多个进程共享的动态库 |

> 小贴士：可以使用 `gcc -###` 观察编译器实际调用的内部工具链。

## 关键细节
- **宏展开顺序**：预处理只执行文本替换，不做语法验证，错误会在编译阶段暴露。
- **头文件保护**：`#ifndef/#define/#endif` 或 `#pragma once` 防止重复定义引发的编译错误。
- **编译单元**：每个 `.c` 文件在预处理后形成独立的翻译单元，链接时再拼接在一起。
- **优化级别**：`-O0/-O1/-O2/-O3/-Ofast` 控制优化力度，调试阶段建议使用 `-O0 -g`。
- **警告控制**：`-Wall -Wextra -Werror` 帮助提前发现潜在问题。

## 链接过程
- **符号解析**：链接器在符号表中查找函数和全局变量定义与引用的配对关系。
- **库搜索顺序**：`gcc main.c -lm` 中库按出现顺序解析，未使用的对象文件可能被跳过。
- **静态与动态**：静态链接将库复制到目标文件，动态链接在运行时加载 `so` 文件。
- **重定位**：链接器会修改目标文件中的占位地址，使其在最终映像中指向正确位置。

## 常见错误排查
- `undefined reference`：通常是链接阶段找不到符号；检查库的顺序、名称或是否忘记实现函数。
- `multiple definition`：同一符号被多个目标文件定义，确保全局变量在头文件使用 `extern` 声明。
- ABI 不匹配：不同编译选项或标准库版本产生的不兼容，统一编译器版本与选项。

## 调试技巧
- 使用 `nm` 查看目标文件导出的符号；`objdump -d` 反汇编检查机器指令。
- `readelf -d ./app` 可以查看动态链接依赖；`ldd ./app` 验证运行期依赖是否齐全。
- 构建系统中配合 `make` 或 `ninja` 实现增量编译，显著缩短迭代时间。
