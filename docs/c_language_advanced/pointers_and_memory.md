# 指针与内存布局

## 指针模型
- 指针存储内存地址，其大小与平台相关(32 位为 4 字节，64 位通常是 8 字节)。
- 指针类型决定解引用时的步长和语义，`int *` 与 `char *` 的指针算术结果不同。
- `void *` 可指向任意类型的数据，但在解引用前需转换为具体类型。

## 指针算术
- `ptr + n` 实际地址偏移量为 `n * sizeof(*ptr)`。
- 在数组中遍历常使用指针算术，需确保不越界：

```c
int sum(const int *begin, const int *end) {
    int total = 0;
    for (const int *p = begin; p < end; ++p) {
        total += *p;
    }
    return total;
}
```

## 多级指针
- `T **` 表示指向 `T *` 的指针，常见于动态数组、函数需要修改指针值的场景。
- `char **argv`：命令行参数列表；`int **matrix`：指向指针数组的地址。

## 指针与数组的关系
- 数组名在大多数表达式中会隐式转换为指向首元素的指针。
- 例外：`sizeof(array)` 返回整个数组字节数；`&array` 返回数组指针(`T (*)[N]`)。

## 内存布局
- 栈：局部变量存储，自动分配与释放，容量有限。
- 堆：通过 `malloc`/`free` 管理，生命周期由程序员控制。
- 全局/静态区：包含全局变量、静态变量与常量字符串。
- 代码区：存储程序指令，只读。

## 别名与效果
- 多个指针指向同一对象时发生别名，编译器优化需考虑 `restrict` 关键字提示无别名。
- 使用 `restrict` 帮助优化：

```c
void saxpy(size_t n, float a, float * restrict x, float * restrict y) {
    for (size_t i = 0; i < n; ++i) {
        y[i] += a * x[i];
    }
}
```

## 对齐与未定义行为
- 指针必须指向对齐地址，强制转换指针类型后如果不满足对齐要求会触发未定义行为。
- `memcpy` 是安全的类型转移方式；避免直接将 `char *` 强转为对齐要求更严格的指针。

## 指针安全
- 初始化：声明指针后立即赋值，避免悬空或野指针。
- 边界：任何指针算术都应确保地址落在合法对象内或对象尾后一位。
- 生命周期：指针指向的对象释放后需及时置 `NULL`，并避免重复释放。
- 混合接口时约定所有权，如谁负责 `free`，可在函数命名或文档中明确。

## 内存布局调试
- `printf("%p\n", (void *)ptr);` 输出地址。
- `gdb` 中使用 `p &variable`、`x/8xb ptr` 查看内存内容。
- 利用 `offsetof` 和 `sizeof` 分析结构体布局，定位对齐问题。
