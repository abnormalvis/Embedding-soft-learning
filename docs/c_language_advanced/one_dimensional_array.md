# 一维数组

## 语法基础
- 一维数组是相同类型元素的连续存储集合，通过下标访问。
- 声明形式：`类型 数组名[元素个数];`
- 下标从 0 开始，范围 `[0, n-1]`。

```c
int values[5];           // 未初始化
int primes[5] = {2, 3, 5, 7, 11};
int zeros[10] = {0};     // 部分初始化，其余补零
int auto_size[] = {1, 2, 3};  // 编译器推断大小
```

## 内存剖析
- 数组在内存中连续分配，地址从低到高递增。
- `sizeof(array)` 返回整个数组字节数，而非首元素地址。
- 数组名在大多数表达式中退化为指向首元素的指针。

```c
int nums[5] = {10, 20, 30, 40, 50};
printf("sizeof(nums)=%zu\n", sizeof(nums));           // 20 bytes (5 * 4)
printf("&nums[0]=%p &nums[1]=%p\n", &nums[0], &nums[1]);
// 地址差为 4 字节（int 大小）
```

### 数组与指针的关系
- `nums` 等价于 `&nums[0]`，类型为 `int *`。
- `nums + i` 指向第 `i` 个元素，`*(nums + i)` 等价于 `nums[i]`。
- `&nums` 的类型是 `int (*)[5]`，指向整个数组。

## 遍历方式
```c
// 下标遍历
for (size_t i = 0; i < 5; ++i) {
    printf("%d ", nums[i]);
}

// 指针遍历
for (int *p = nums; p < nums + 5; ++p) {
    printf("%d ", *p);
}
```

## 应用场景
- **数据缓冲区**：临时存储固定数量的输入或计算结果。
- **查找表**：预先计算的常量数组，如三角函数表、编码映射。
- **栈模拟**：使用数组 + 索引实现简单的栈结构。
- **小规模数据处理**：排序、统计、过滤等操作的数据载体。

## 边界检查
- C 不会自动检查数组越界，访问无效索引导致未定义行为。
- 使用循环时确保索引在 `[0, n-1]` 范围内。
- 调试时可使用 AddressSanitizer 检测越界访问。

## 与动态内存对比
- 栈数组大小固定，编译期确定；动态数组通过 `malloc` 运行时分配。
- 栈数组自动释放，无需手动管理；堆数组需要 `free`。
- 大数组应使用堆分配，避免栈溢出。
